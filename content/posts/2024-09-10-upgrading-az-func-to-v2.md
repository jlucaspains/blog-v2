---
layout: post
title: "Sharp Cooking - How to upgrade Python Azure Functions from v1 to v2"
date: 2024-09-10
categories:
  - azure
  - python
description: >-
    Upgrading Sharp Cooking API to Python Azure Functions v2 simplifies code, enhances organization, and enables new features like streaming.
cover:
    image: "/images/posts/sharp-cooking-api-v1-v2-cover.webp"
    alt: "Image generated by ChatGPT based on post content"
    caption: "Image generated by ChatGPT based on post content"
---

For a while, I’ve been using Python Azure Functions to power the Sharp Cooking Backend API. When I first created the API, the v2 programming model [was still in preview](https://azure.microsoft.com/en-us/updates/generally-available-v2-programming-model-for-azure-functions-using-python/#:~:text=Published%20date%3A%20May%2023%2C%202023,more%20familiar%20to%20Python%20developers.) and not fully ready. Now that it's generally available, I finally upgraded. The v2 model reduces boilerplate code and adds features that weren’t previously possible—such as [streaming responses](https://azure.microsoft.com/en-us/updates/public-preview-azure-functions-support-for-http-streams-in-python/), which is great for LLM models.

Here’s a quick overview of the process and what changed.

## TL;DR
For the actual code changes, check out [this SharpCooking PR](https://github.com/jlucaspains/sharp-cooking-web/pull/336).

## 1. Simplified Folder Structure
In v1, each function required its own folder and a function.json file. In v2, you can have multiple functions in the same folder, or even in a single file. Configuration is now handled with decorators instead of `function.json` files.

I decided to keep only the main `function_app.py` file in the API root and move all the functions into a functions folder. For easier navigation, I kept each function in its own file.

Before:
![V1 model](/images/posts/sharp-cooking-api-before.png)

After:
![V2 model](/images/posts/sharp-cooking-api-after.png)

## 2. Adjusting the Imports
To get the imports working again, I had to update all the files, including the unit tests. I also used this opportunity to rename all the `main.py` files to match the function names.

Example:

```python
# From
from ..parse_recipe.main import main

# To
from ..functions.parse_recipe import parse_recipe
```

## 3. Using Blueprints to Register Multiple Functions
In v2, you can use blueprints to register multiple functions across different files or modules. Each function exposes a blueprint object where you define routes. In the main function file, typically `function_app.py`, you then import and register these blueprints.

In the function:
```python
import azure.functions as func

bp = func.Blueprint()

@bp.route(route="parse-recipe", methods=["POST"]) 
def parse_recipe(req: func.HttpRequest) -> func.HttpResponse:
  # parse the recipe here
```

In the `function_app.py` file:
```python
import azure.functions as func
from functions.parse_recipe import bp as parse_recipe_bp

app = func.FunctionApp(http_auth_level=func.AuthLevel.FUNCTION)

app.register_functions(parse_recipe_bp)
```

## 4. Updating Unit Tests
You can’t directly call the function in unit tests anymore; you need to use the `Build()` method to get the user function. This is explained in the [Azure Functions documentation](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-python).

```python
import unittest
from ..functions.parse_recipe import parse_recipe

def test_recipe_parse():
  # prepare the request
  request = func.HttpRequest(
        method='POST',
        url='api/parse-recipe',
        body=json.dumps({
            'url': 'https://www.foodnetwork.com/recipes/rachael-ray/pork-chops-with-golden-apple-sauce-recipe-1915826',
        }).encode('utf8')
    )

    # you cannot call the function directly, you need to use the build()
    # method to get the user function
    func_call = parse_recipe.build().get_user_function()
    response = func_call(request)

    # assert response
    assert response.status_code == 200
```

## Conclusion
The upgrade process was pretty straightforward, and I’m happy with the results. The code is cleaner and easier to navigate. I’m looking forward to leveraging streaming responses and other new features in v2 for future Sharp Cooking features.

Cheers,\
Lucas